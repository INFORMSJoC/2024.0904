#pragma once
#ifndef __BRON
#define __BRON

#include <iostream>
#include <vector>
#include <set>
#include <algorithm>
#include <tuple>


class BK
{
public:
    int N;
    void run();
    std::set<std::set<int>> maxCliques;
    BK(int N, std::vector< std::tuple<int, int> > adj);     // the constructor function, the iuput is adj: the set of edges
    void print();
private:
    std::vector< std::vector<bool> > graph;   // a graph generated by BK
    void printSet(std::set<int> set_a);
    std::set<int> neighbor(int v, std::vector< std::vector<bool> > g);
    std::set<int> intersection(std::set<int> set_a, std::set<int> set_b);
    void BronKerbosch(std::set<int> R, std::set<int> P, std::set<int> X);
};


BK::BK(int num_nodes, std::vector< std::tuple<int, int> > adj)
{
    N = num_nodes;
    for (int i = 0; i < N; i++)
    {
        std::vector<bool> row(N, false);
        graph.push_back(row);
    }
    for (int i = 0; i < adj.size(); i++)
    {
        int o = std::get<0>(adj[i]) - 1;
        int d = std::get<1>(adj[i]) - 1;
        graph[o][d] = true;
        graph[d][o] = true;
    }

    // print out the graph
    //std::cout << "graph: " << std::endl;
    //for (int i = 0; i < graph.size(); i++)
    //{
    //    for (int j = 0; j < graph[i].size(); j++)
    //        std::cout << graph[i][j] << " ";
    //    std::cout << std::endl;
    //}
}


void BK::printSet(std::set<int> set_a)
{
    std::cout << "{ ";
    for (auto& e : set_a) {
        std::cout << e << " ";
    }
    std::cout << "}" << std::endl;
}

std::set<int> BK::neighbor(int v, std::vector< std::vector<bool> > g)
{
    std::set<int> result;
    for (int i = 1; i <= N; i++) {
        if (g[v - 1][i - 1]) {
            result.insert(i);
        }
    }
    return result;
}

std::set<int> BK::intersection(std::set<int> set_a, std::set<int> set_b)
{
    std::set<int> result;
    set_intersection(set_a.begin(), set_a.end(), set_b.begin(), set_b.end(), inserter(result, result.begin()));
    return result;
}


void BK::BronKerbosch(std::set<int> R, std::set<int> P, std::set<int> X)
{
    //cout << "R: ";
    //printSet(R);
    //cout << "P: ";
    //printSet(P);
    //cout << "X: ";
    //printSet(X);
    //cout << "==========================\n";
    if (P.size() == 0 && X.size() == 0)
    {
        //cout << "maximal size: " << R.size() << endl;
        //cout << "set: { ";
        //for (auto& e : R) {
        //    cout << e << " ";
        //}
        //cout << "}" << endl;
        maxCliques.insert(R);
        return;
    }

    int pivot = 1;
    for (pivot = 1; pivot <= N; pivot++)
    {
        if (P.count(pivot) || X.count(pivot))
        {
            //cout << "pivot: " << pivot << endl;
            break;
        }
    }

    for (int i = 1; i <= N; i++) {
        if (P.count(i) && !graph[pivot - 1][i - 1]) {
            R.insert(i);
            BronKerbosch(R, intersection(P, neighbor(i, graph)), intersection(X, neighbor(i, graph)));
            R.erase(i);
            P.erase(i);
            X.insert(i);
        }
    }
}


void BK::run()
{
    std::set<int> R, P, X;
    for (int i = 0; i < graph.size(); i++) P.insert(i + 1);
    BronKerbosch(R, P, X);
}


void BK::print()
{
    std::cout << "Maximal cliques:\n";

    for (auto it = maxCliques.begin(); it != maxCliques.end(); it++)
    {
        std::cout << "{";

        auto it2 = (*it).begin();
        std::cout << (*it2); ++it2;

        for (; it2 != (*it).end(); ++it2)
            std::cout << ", " << (*it2);
        std::cout << "}\n";
    }
}

#endif

